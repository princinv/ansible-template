# ansible.cfg

# ==========================================
# ANSIBLE CONFIGURATION
# ==========================================

[defaults]
# ------------------------------------------
# DEFAULTS - DEBUG/LOGGING/SU
# ------------------------------------------
# (boolean) Toggle the use of "su" for tasks.
su = False
# (boolean) Toggles debug output in Ansible. This is *very* verbose and can hinder multiprocessing.  Debug output can also include secret information despite no_log settings being enabled, which means debug mode should not be used in production.
debug = False
# (boolean) Whether or not to enable the task debugger, this previously was done as a strategy plugin.
# Now all strategy plugins can inherit this behavior. The debugger defaults to activating when
# a task is failed on unreachable. Use the debugger keyword for more flexibility.
enable_task_debugger = False
# (boolean) Toggle Ansible's display and logging of task details, mainly used to avoid security disclosures.
no_log = False
# (boolean) Toggle Ansible logging to syslog on the target when it executes tasks. On Windows hosts this will disable a newer style PowerShell modules from writing to the event log.
no_target_syslog = False
# (path) File to which Ansible will log on the controller. When empty logging is disabled.
# static log overwritten each run; disabled to allow bootstrap.py to log with timestamp
# log_path = ./log/ansible.log 
# (list) List of logger names to filter out of the log file
;log_filter = 
# (integer) Sets the default verbosity, equivalent to the number of ``-v`` passed in the command line.
verbosity = 0
# (bool) Force 'verbose' option to use stderr instead of stdout
verbose_to_stderr = False
# (boolean) Normally ``ansible-playbook`` will print a header for each task that is run. These headers will contain the name: field from the task if you specified one. If you didn't then ``ansible-playbook`` uses the task's action to help you tell which task is presently running. Sometimes you run many of the same action and so you want more information about the task to differentiate it from others of the same action. If you set this variable to True in the config then ``ansible-playbook`` will also include the task's arguments in the header.
# This setting defaults to False because there is a chance that you have sensitive values in your parameters and you do not want those to be printed.
# If you set this to True you should be sure that you have secured your environment's stdout (no one can shoulder surf your screen and you aren't saving stdout to an insecure file) or made sure that all of your playbooks explicitly added the ``no_log: True`` parameter to tasks which have sensitive values See How do I keep secret data in my playbook? for more information.
display_args_to_stdout = False
# (boolean) Toggle to control displaying skipped task/host entries in a task in the default callback
display_skipped_hosts = True
# (boolean) Toggle to control the showing of deprecation warnings
action_warnings = True
# (string) When a collection is loaded that does not support the running Ansible version (with the collection metadata key `requires_ansible`).
collections_on_ansible_version_mismatch = warning
# (boolean) Sets the default value for the any_errors_fatal keyword, if True, Task failures will be considered fatal errors.
deprecation_warnings = True
# (boolean) Toggle to control showing warnings related to running devel
devel_warning = True
# (string) By default Ansible will issue a warning when a duplicate dict key is encountered in YAML.
# These warnings can be silenced by adjusting this setting to False.
duplicate_dict_key = warn
# (boolean) Toggle to control showing warnings related to running a Jinja version older than required for jinja2_native
jinja2_native_warning = True
# (boolean) By default Ansible will issue a warning when there are no hosts in the inventory.
# These warnings can be silenced by adjusting this setting to False.
localhost_warning = True
# (boolean) Allows disabling of warnings related to potential issues on the system running ansible itself (not on the managed hosts)
# These may include warnings about 3rd party packages or other conditions that should be resolved if possible.
system_warnings = True
# (integer) For asynchronous tasks in Ansible (covered in Asynchronous Actions and Polling), this is how often to check back on the status of those tasks when an explicit poll interval is not supplied. The default is a reasonably moderate 15 seconds which is a tradeoff between checking in frequently and providing a quick turnaround when something may have completed.
poll_interval = 15
# (bool) This adds the custom stats set via the set_stats plugin to the default output
show_custom_stats = True

# ------------------------------------------
# DEFAULTS - PATHS
# ------------------------------------------
# (path) The default root path for Ansible config files on the controller.
home = ~/.ansible
# (pathlist) Comma separated list of Ansible inventory sources
inventory = ./inventory/hosts.yml
# (pathspec) Colon separated paths in which Ansible will search for Roles.
roles_path = ./roles
# (pathspec) Colon separated paths in which Ansible will search for Modules.
library = ./library
# (pathspec) Colon separated paths in which Ansible will search for Module utils files, which are shared by modules.
module_utils = ./library/module_utils
# (boolean) This option controls if notified handlers run on a host even if a failure occurs on that host.
# When false, the handlers will not run if a failure has occurred on a host.
# This can also be set per play or on the command line. See Handlers and Failure for more details.
force_handlers = False
# (pathspec) Colon separated paths in which Ansible will search for collections content. Collections must be in nested *subdirectories*, not directly in these directories. For example, if ``COLLECTIONS_PATHS`` includes ``'{{ ANSIBLE_HOME ~ "/collections" }}'``, and you want to add ``my.collection`` to that directory, it must be saved as ``'{{ ANSIBLE_HOME} ~ "/collections/ansible_collections/my/collection" }}'``.
collections_path = ./collections
# (boolean) A boolean to enable or disable scanning the sys.path for installed collections
collections_scan_sys_path = True
# (boolean) When enabled, this option allows lookup plugins (whether used in variables as ``{{lookup('foo')}}`` or as a loop as with_foo) to return data that is not marked 'unsafe'.
# By default, such data is marked as unsafe to prevent the templating engine from evaluating any jinja2 templating language, as this could represent a security risk. This option is provided to allow for backward compatibility, however users should first consider adding allow_unsafe=True to any lookups which may be expected to contain data which may be run through the templating engine late
allow_unsafe_lookups = False
# (pathspec) Colon separated paths in which Ansible will search for Become Plugins.
become_plugins =./plugins/become_plugins
# (pathspec) Colon separated paths in which Ansible will search for Action Plugins.
action_plugins= ./plugins/action_plugins
# (pathspec) Colon separated paths in which Ansible will search for Cache Plugins.
cache_plugins = ./plugins/cache_plugins
# (list) List of enabled callbacks, not all callbacks need enabling, but many of those shipped with Ansible do as we don't want them activated by default.
callbacks_enabled = bootstrap, ansible.builtin.default, ansible.posix.timer, ansible.posix.profile_tasks, ansible.posix.profile_roles, community.general.mail, community.grafana.grafana_annotations, community.general.timestamp
# (pathspec) Colon separated paths in which Ansible will search for Callback Plugins.
callback_plugins = ./plugins/callback_plugins
# (boolean) Controls whether callback plugins are loaded when running /usr/bin/ansible. This may be used to log activity from the command line, send notifications, and so on. Callback plugins are always loaded for ``ansible-playbook``.
bin_ansible_callbacks = False
# (pathspec) Colon separated paths in which Ansible will search for Cliconf Plugins.
cliconf_plugins = ./plugins/cliconf_plugins
# (pathspec) Colon separated paths in which Ansible will search for Connection Plugins.
connection_plugins = ./plugins/connection_plugins
# (pathspec) Colon separated paths in which Ansible will search for Jinja2 Filter Plugins.
filter_plugins = ./plugins/filter_plugins
# (pathspec) Colon separated paths in which Ansible will search for HttpApi Plugins.
httpapi_plugins = ./plugins/httpapi_plugins
# (pathspec) Colon separated paths in which Ansible will search for Inventory Plugins.
inventory_plugins = ./plugins/inventory_plugins
# (list) List of enabled inventory plugins, it also determines the order in which they are used.
enable_plugins = host_list, script, auto, yaml, ini, toml
# (pathspec) Colon separated paths in which Ansible will search for Lookup Plugins.
lookup_plugins = ./plugins/lookup_plugins
# (pathspec) Colon separated paths in which Ansible will search for Netconf Plugins.
netconf_plugins = ./plugins/netconf_plugins
# (string) Set the default strategy used for plays.
strategy = linear
# (pathspec) Colon separated paths in which Ansible will search for Strategy Plugins.
strategy_plugins = ./plugins/strategy_plugins
# (pathspec) Colon separated paths in which Ansible will search for Terminal Plugins.
terminal_plugins = ./plugins/terminal_plugins
# (pathspec) Colon separated paths in which Ansible will search for Jinja2 Test Plugins.
test_plugins = ./plugins/test_plugins
# (pathspec) Colon separated paths in which Ansible will search for Vars Plugins.
vars_plugins = ./plugins/vars_plugins
# (pathspec) Colon separated paths in which Ansible will search for Documentation Fragments Plugins.
doc_fragment_plugins = ./plugins/doc_fragment_plugins

# ------------------------------------------
# DEFAULTS - BEHAVIOR
# ------------------------------------------
# (boolean) This controls whether an Ansible playbook should prompt for a login password. If using SSH keys for authentication, you probably do not need to change this setting.
# ask_pass = False
# (path) The password file to use for the connection plugin. --connection-password-file.
# connection_password_file =
# (string) Can be any connection plugin available to your ansible installation.
# There is also a (DEPRECATED) special 'smart' option, that will toggle between 'ssh' and 'paramiko' depending on controller OS and ssh versions.
transport = ssh
# (integer) This is the default timeout for connection plugins to use.
timeout = 30 
# pipelining true to speed up execution by reducing SSH overhead
# (path) The password file to use for the become plugin. --become-password-file.
# If executable, it will be run and the resulting stdout will be used as the password.
# become_password_file = 
# (path) Option for connections using a certificate or key file to authenticate, rather than an agent or passwords, you can set the default value here to avoid re-specifying --private-key with every invocation.
# private_key_file = 
# can be set to false if needed, but presents sec issue
host_key_checking = True
# (string) This indicates the command to use to spawn a shell under for Ansible's execution needs on a target. Users may need to change this in rare instances when shell usage is constrained, but in most cases it may be left as is.
executable = /bin/sh
retry_files_enabled = False
# (integer) Maximum number of forks Ansible will use to execute tasks on target hosts.
forks = 4
# (float) This sets the interval (in seconds) of Ansible internal processes polling each other. Lower values improve performance with large playbooks at the expense of extra CPU load. Higher values are more suitable for Ansible usage in automation scenarios, when UI responsiveness is not required but CPU usage might be a concern.
# The default corresponds to the value hardcoded in Ansible <= 2.1
internal_poll_interval = 0.001
# stdout_callback options: yaml, json, debug (very verbose), dense (minimal)
stdout_callback = default
# (boolean) By default Ansible will issue a warning when received from a task action (module or action plugin)
# These warnings can be silenced by adjusting this setting to False.
any_errors_fatal = False
# (boolean) When True, this causes ansible templating to fail steps that reference variable names that are likely typoed.
# Otherwise, any '{{ template_expression }}' that contains undefined variables will be rendered in a template or ansible action line exactly as written.
error_on_undefined_vars = True
# (boolean) Toggle to allow missing handlers to become a warning instead of an error when notifying.
error_on_missing_handler = True
# (boolean) If 'false', invalid attributes for a task will result in warnings instead of errors
invalid_task_attribute_failed = True
# (int) Maximum size of files to be considered for diff display
max_diff_size = 104448

# ------------------------------------------
# DEFAULTS - VAULT
# ------------------------------------------
# (boolean) This controls whether an Ansible playbook should prompt for a vault password.
ask_vault_pass = False
# (string) The vault_id to use for encrypting by default. If multiple vault_ids are provided, this specifies which to use for encryption. The --encrypt-vault-id cli option overrides the configured value.
vault_encrypt_identity = prod
# (string) The label to use for the default vault id label in cases where a vault id label is not provided
vault_identity = default
# (list) A list of vault-ids to use by default. Equivalent to multiple --vault-id args. Vault-ids are tried in order.
# vault_identity_list = 
# (string) If true, decrypting vaults with a vault id will only try the password from the matching vault-id
vault_id_match = False
# (path) The vault password file to use. Equivalent to --vault-password-file or --vault-id
# If executable, it will be run and the resulting stdout will be used as the password.
;vault_password_file=

# ------------------------------------------
# DEFAULTS - FACT GATHERING
# ------------------------------------------
# disable gather facts for faster execution
gather_facts = True
# (list) Which modules to run during a play's fact gathering stage, using the default of 'smart' will try to figure it out based on connection type.
# If adding your own modules but you still want to use the default Ansible facts, you will want to include 'setup' or corresponding network module to the list (if you add 'smart', Ansible will also figure it out).
# This does not affect explicit calls to the 'setup' module, but does always affect the 'gather_facts' action (implicit or explicit).
facts_modules = smart
# (string) Chooses which cache plugin to use, the default 'memory' is ephemeral.
fact_caching = jsonfile
# (string) Defines connection or path information for the cache plugin
fact_caching_connection = /tmp/ansible_fact_cache
# (string) Prefix to use for cache plugin files/tables
fact_caching_prefix = ansible_facts
# (integer) Expiration timeout for the cache plugin data
fact_caching_timeout = 86400
# (string) This setting controls the default policy of fact gathering (facts discovered about remote systems).
# This option can be useful for those wishing to save fact gathering time. Both 'smart' and 'explicit' will use the cache plugin.
gathering = smart 
# (list) Set the `gather_subset` option for the :ref:`ansible_collections.ansible.builtin.setup_module` task in the implicit fact gathering. See the module documentation for specifics.
# It does **not** apply to user defined ``ansible.builtin.setup`` tasks.
# gather_subset = all  # DEPRECATED, USER MODULE_DEFAULTS KEYWORD (more generic and cna apply to all calls to gather facts and setup actions)
# (integer) Set the timeout in seconds for the implicit fact gathering, see the module documentation for specifics.
# It does **not** apply to user defined :ref:`ansible_collections.ansible.builtin.setup_module` tasks.
# gather_timeout = 60  # DEPRECATED, USER MODULE_DEFAULTS KEYWORD (more generic and cna apply to all calls to gather facts and setup actions)

# ------------------------------------------
# DEFAULTS - TEMPLATING
# ------------------------------------------
# (string) This is a developer-specific feature that allows enabling additional Jinja2 extensions.
# See the Jinja2 documentation for details. If you do not know what these do, you probably don't need to change this setting :)
# jinja2_extensions = []
# (boolean) This option preserves variable types during template operations.
jinja2_native = False
# (string) This setting controls how duplicate definitions of dictionary variables (aka hash, map, associative array) are handled in Ansible.
# This does not affect variables whose values are scalars (integers, strings) or arrays.
# **WARNING**, changing this setting is not recommended as this is fragile and makes your content (plays, roles, collections) non portable, leading to continual confusion and misuse. Don't change this setting unless you think you have an absolute need for it.
# We recommend avoiding reusing variable names and relying on the ``combine`` filter and ``vars`` and ``varnames`` lookups to create merged versions of the individual variables. In our experience this is rarely really needed and a sign that too much complexity has been introduced into the data structures and plays.
# For some uses you can also look into custom vars_plugins to merge on input, even substituting the default ``host_group_vars`` that is in charge of parsing the ``host_vars/`` and ``group_vars/`` directories. Most users of this setting are only interested in inventory scope, but the setting itself affects all sources and makes debugging even harder.
# All playbooks and roles in the official examples repos assume the default for this setting.
# Changing the setting to ``merge`` applies across variable sources, but many sources will internally still overwrite the variables. For example ``include_vars`` will dedupe variables internally before updating Ansible, with 'last defined' overwriting previous definitions in same file.
# The Ansible project recommends you **avoid ``merge`` for new projects.**
# It is the intention of the Ansible developers to eventually deprecate and remove this setting, but it is being kept as some users do heavily rely on it. New projects should **avoid 'merge'**.
hash_behaviour = replace
# (tmppath) Temporary directory for Ansible to use on the controller.
local_tmp = /tmp
# (boolean) Enables/disables the cleaning up of the temporary files Ansible used to execute the tasks on the remote.
# If this option is enabled it will disable ``ANSIBLE_PIPELINING``.
keep_remote_files = False
# (raw) What templating should return as a 'null' value. When not set it will let Jinja2 decide.
# null_representation = 
# (boolean) By default, imported roles publish their variables to the play and other roles, this setting can avoid that.
# This was introduced as a way to reset role variables to default values if a role is used more than once in a playbook.
# Included roles only make their variables public at execution, unlike imported roles which happen at playbook compile time.
private_role_vars = False
# (boolean) Facts are available inside the `ansible_facts` variable, this setting also pushes them as their own vars in the main namespace.
# Unlike inside the `ansible_facts` dictionary, these will have an `ansible_` prefix.
inject_facts_as_vars = True
# (list) Check all of these extensions when looking for 'variable' files which should be YAML or JSON or vaulted versions of these.
# This affects vars_files, include_vars, inventory and vars plugins among others.
yaml_valid_extensions = .yml, .yaml, .json

# ------------------------------------------
# DEFAULTS - MODULES
# ------------------------------------------
# (string) Sets the macro for the 'ansible_managed' variable available for :ref:`ansible_collections.ansible.builtin.template_module` and :ref:`ansible_collections.ansible.windows.win_template_module`.  This is only relevant for those two modules.
ansible_managed = Ansible managed
# (string) Compression scheme to use when transferring Python modules to the target.
module_compression = ZIP_DEFLATED
# (string) Path to the Python interpreter to be used for module execution on remote targets, or an automatic discovery mode. Supported discovery modes are ``auto`` (the default), ``auto_silent``, ``auto_legacy``, and ``auto_legacy_silent``. All discovery modes employ a lookup table to use the included system Python (on distributions known to include one), falling back to a fixed ordered list of well-known Python interpreter locations if a platform-specific default is not available. The fallback behavior will issue a warning that the interpreter should be set explicitly (since interpreters installed later may change which one is used). This warning behavior can be disabled by setting ``auto_silent`` or ``auto_legacy_silent``. The value of ``auto_legacy`` provides all the same behavior, but for backwards-compatibility with older Ansible releases that always defaulted to ``/usr/bin/python``, will use that interpreter if present.
interpreter_python = auto
# (boolean) Previously Ansible would only clear some of the plugin loading caches when loading new roles, this led to some behaviours in which a plugin loaded in previous plays would be unexpectedly 'sticky'. This setting allows to return to that behaviour.
old_plugin_cache_clear = False

# ------------------------------------------
# DEFAULTS - APPEARANCE
# ------------------------------------------
colorized = True
# (boolean) This setting allows suppressing colorizing output, which is used to give a better indication of failure and status information.
nocolor = False
# (boolean) This option forces color mode even when running without a TTY or the "nocolor" setting is True.
force_color = False
# (boolean) If you have cowsay installed but want to avoid the 'cows' (why????), use this.
nocows = True
# (list) Accept list of cowsay templates that are 'safe' to use, set to empty list if you want to enable all installed templates.
cowsay_enabled_stencils = bud-frogs, bunny, cheese, daemon, default, dragon, elephant-in-snake, elephant, eyes, hellokitty, kitty, luke-koala, meow, milk, moofasa, moose, ren, sheep, small, stegosaurus, stimpy, supermilker, three-eyes, turkey, turtle, tux, udder, vader-koala, vader, www
# (string) This allows you to chose a specific cowsay stencil for the banners or use 'random' to cycle through them.
cow_selection = tux


[privilege_escalation]
# (boolean) Toggles the use of privilege escalation, allowing you to 'become' another user after login.
become = True
# (string) The user your login/remote user 'becomes' when using privilege escalation, most systems will use 'root' when no user is specified.
become_user = root
# (boolean) Toggle to prompt for privilege escalation password.
become_ask_pass = True 
# (string) Privilege escalation method to use when `become` is enabled.
become_method = sudo
# (boolean) This setting controls if become is skipped when remote user and become user are the same. I.E root sudo to root.
# If executable, it will be run and the resulting stdout will be used as the password.
become_allow_same_user = False


[connection]
piplining = false  
# apply specific SSH command arguments
# ssh_args = 


[colors]
# (string) Defines the color to use on 'Changed' task status
changed = yellow
# (string) Defines the default color to use for ansible-console
console_prompt = white
# (string) Defines the color to use when emitting debug messages
debug = dark gray
# (string) Defines the color to use when emitting deprecation messages
deprecate = purple
# (string) Defines the color to use when showing added lines in diffs
diff_add = green
# (string) Defines the color to use when showing diffs
diff_lines = cyan
# (string) Defines the color to use when showing removed lines in diffs
diff_remove = red
# (string) Defines the color to use when emitting error messages
error = red
# (string) Defines the color to use for highlighting
highlight = white
# (string) Defines the color to use when showing 'OK' task status
ok = green
# (string) Defines the color to use when showing 'Skipped' task status
skip = cyan
# (string) Defines the color to use on 'Unreachable' status
unreachable = bright red
# (string) Defines the color to use when emitting verbose messages. i.e those that show with '-v's.
verbose = blue


[selinux]
# (boolean) This setting causes libvirt to connect to lxc containers by passing --noseclabel to virsh. This is necessary when running on systems which do not have SELinux.
libvirt_lxc_noseclabel = False

# (list) Some filesystems do not support safe operations and/or return inconsistent errors, this setting makes Ansible 'tolerate' those in the list w/o causing fatal errors.
# Data corruption may occur and writes are not always verified when a filesystem is in the list.
special_context_filesystems = fuse, nfs, vboxsf, ramfs, 9p, vfat


[diff]
# (bool) Configuration toggle to tell modules to show differences when in 'changed' status, equivalent to ``--diff``.
# always = True

# (integer) How many lines of context to show when displaying the differences between files.
# context = 3


[galaxy]
# (bool) whether ``ansible-galaxy collection install`` should warn about ``--collections-path`` missing from configured :ref:`collections_paths`
collections_path_warning = True
# (path) Role skeleton directory to use as a template for the ``init`` action in ``ansible-galaxy``/``ansible-galaxy role``, same as ``--role-skeleton``.
role_skeleton = roles/.role.tmpl
# (list) patterns of files to ignore inside a Galaxy role or collection skeleton directory
role_skeleton_ignore = ^.git$, ^.*/.git_keep$


[inventory]
# (string) This setting changes the behaviour of mismatched host patterns, it allows you to force a fatal error, a warning or just ignore it
host_pattern_mismatch = warning
# (boolean) If 'true', it is a fatal error when any given inventory source cannot be successfully parsed by any available inventory plugin; otherwise, this situation only attracts a warning.
any_unparsed_is_failed = False
# (list) List of extensions to ignore when using a directory as an inventory source
ignore_extensions = {{(REJECT_EXTS + ('.orig', '.ini', '.cfg', '.retry'))}}
# (list) List of patterns to ignore when using a directory as an inventory source
# ignore_patterns = 
# (bool) If 'true' it is a fatal error if every single potential inventory source fails to parse, otherwise this situation will only attract a warning.
unparsed_is_failed = False
# (boolean) By default Ansible will issue a warning when no inventory was loaded and notes that it will use an implicit localhost-only inventory.
# These warnings can be silenced by adjusting this setting to False.
inventory_unparsed_warning = True


[tags]
# (list) default list of tags to run in your plays, Skip Tags has precedence.
# run = 
# (list) default list of tags to skip in your plays, has precedence over Run Tags
# skip = 
